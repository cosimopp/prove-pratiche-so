per comprendere prefissi e suffissi (printf https://youtu.be/VA22ESilQO0)
		
		char buf[100];
    	va_list args; //(variadic) needs initialization
		
    	printf("Example\n");

    	f = > fprintf(stdout, "Example\n"); //dealing with stream e.g. file
		//safer version
    	_s  => fprintf_s(stdout, "Example\n"); //"instead of just calling the function, check if parameters are okay 
    	//before doing the operation so it doesn't crash the application" (C11)
    	
    	s => sprintf(buf, "Example\n"); //sovrascrive
    	
    	sn => snprintf(buf, 3, "12345\n"); // => buf = 123, len(buf) = 100
    	
    	v => vfprintf(stdout, "Example\n", args); //syscall gets a va_list or vector as a single argument
    	execv(const char *pathname, char *const argv[]);

		//wide-character
    	w => fwprintf_s(stdout, "Example\n"); //treats formatted string as being a wide char array => each char
		//is more than just one byte

		"p" usually stands for program file vs pathname 
		execlp("ls", ...) vs execl("/bin/ls", ...) //relies on PATH

		"l" usually stands for list or link

		"e" usually stands for environment 

		"_r" usually stands for reentrant.
		You can call reentrant functions from multiple threads simultaneously, or in nested loops, et cetera. Reentrant versions usually take an extra argument, this argument is used to store state between calls instead of using a global variable.
		
		char *strtok(char *str, const char *delim) {
    		static char *save;
    		return strtok_r(str, delim, &save);
		}

		toDo: "u"